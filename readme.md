# О проекте
Это учебный проект - Домашнее задание по курсу обучения по git от yandex education.
[Ссылка на курс](https://practicum.yandex.ru/profile/git-basics/)
Пример файла .md в репозитарии github c краткой шпаргалкой по типовым операциям 
# Шпаргалка по GIT
## Общие сведения
**GIT** –система контроля версий с активной поддержкой и открытым исходным кодом. Консольное приложение GitBrush позволяет работать с локальными репозиториями (хранилищами файлов) и синхронизировать их с облачными репозиториями.
Подробнее:  
[Книжка по Git](https://git-scm.com/book/ru/v2)

**GITHUB** – облачное решение от Microsoft для контроля версий с хранением репозиториев в облаке. Это облачная платформа где программисты могут хранить свои проекты, контролировать их версии и публиковать их.  
[Ссылка на GitHub](https://github.com/)

## Начало работы с Git:
1. Скачать и поставить дистрибутив под нужную ОС:  
https://git-scm.com/download/

## Создать локальный репозитарий (на примере простейшего проекта с одним файлом): 
1. Запустить GitBrush
2. Переходим в домашний каталог  
cd  ~
3. Создаем папку для своих локальных проектов git в домашнем каталоге:  
mkdir git
4. Создаем папку проекта:  
mkdir ~\git\testprogect
5. Заходим в папку проекта  
cd ~\git\testprogect
6. Создаем пустой файл с описанием проекта:  
touch readme.md
7. Инициализируем локальный репозитарий git:  
git init
8. Проверяем, что в папке проекта появилась папка репозитрия .git  
ls –al
9. Проверяем статус репозитария  
git status
10. Добавляем все файлы из текущей папки к коммиту (можно добалять все –all или отдельные файла по именам). Далее в рамках коммита будет зафиксирвоана версия добавленных файлов  
git add .
11. Выполняем коммит (фиксируем состояние добавленных файлов, чтобы впоследствии контролировать внесенные в них изменения). К каждому коммиту (слепку, состоянию) можно добавлятькомментарий  
git commit -m "Пустой репозиторий"

## Настройка GitHub и синхронизация с локальным репозитарием
1. Заходим на github и создаем аккаунт, набор ключей доступа и репозитарий для нашего проекта по документации:  
[Быстрый старт по GitHub](https://docs.github.com/ru/get-started/quickstart)
2. В разделе "Quick setup — if you’ve done this kind of thing before" созданного репозитария копируем путь к репозитарию и связываем локальный репозитарий с созданным репозитарием на github:  
git remote add origin <сюда вставить путь к репозитория>
3. Проверить репозитарий:  
git remote –v
4. Передать локальный репозитарий на GitHub (ключ –u и название origin и ветки master нужно только первый раз):  
git push -u origin master
5. В любом текстовом редакторе заполняем файл readme.md используя разметку MarkDown, описание разметки здесь:  
https://gist.github.com/fomvasss/8dd8cd7f88c67a4e3727f9d39224a84c
Описание способа оформления графических даграмм в разметке здесь:
https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/
6. Добаить измененный файл к коммиту  
git add readme.md
7. Коммит репозитария  
git commit -m "V1 readme.md – ВВЕДЕН ТЕКСТ" 
8. Отпраить на GitHub обновленную версию репозитария  
git push
9. Проверить результат на GITHUB  
## Команда git log
1. Выаод лога коппитов. Каждый комминт снабжен хэшем
git log
Для выхода из лога - нажать q
2. Вывод лога в сокращенном виде
git log --oneline
3. В логе HEAT - это последний коомит. В папке .git есть файл HEAT который ссылается на хэш последнего коммита
## Жизненный цикл файла в git
1. Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git.
Файл переходит в статус staged после выполнения git add.
2. Статус modified означает, что файл был изменён.
3. Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.
4. Схема жизненного цикла файла в GIT:

```mermaid 
flowchart TD;
 A[Untracked]--git add-->B[Staged];
 B--git commit-->C[Tracked];
 B--изменение-->D[Modified];
 C--изменение-->D[Modified];
 D--git add-->B[Staged]; 
```

## Команда git status
1. Команда git status всегда подскажет, что происходит с файлом: например, он добавлен в с1/писок «на коммит» или ещё вообще не отслеживается, или изменён.
2. git status показывает явно следующие состояния файлов: untracked, staged и modified.
3. git status подсказывает, какие команды можно выполнить, чтобы поменять состояние файла.
## Правила оформления коммитов к версиям
1. Стандарт описания коммитов здесь: https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#спецификация
2. Основные правила оформления коммитов:
- сообщение коммита легко читается;
- оно информативное;
- все сообщения оформлены в одном стиле;
- длина коммита до 72 символов
- если коммит ссылается на задачу в GitHubm, о вставить ссылку на задачу в формате "#номер задачи"
## Редактирование последнего коммита с опцией --amend
1. --amend рассчитан на работу с последним коммитом (HEAD).
2. Дополнить коммит новыми файлами можно с помощью git commit --amend --no-edit. Благодаря опции --no-edit сообщение к коммиту останется таким, каким и было.
3. Изменить сообщение к коммиту позволяет команда git commit --amend -m "Обновлённое сообщение коммита".
## Редакторы VIM и nano
1. Описание редактора nano https://help.ubuntu.ru/wiki/nano
2. Для запука обучалки по VIM набрать vimtutor
3. Основные команды VIM: ESC - выход в командный режим, i - вставка текста, А - добавление текста, x - удаление текста, h,j,k,l - перемещение курсора, :wq - сохранить и выйти.
## Откат к коммиту или откат изменений файла
1. Команда git restore --staged \<file\> переведёт файл из staged обратно в modified или untracked.
2. Команда git reset --hard \<commit hash\> «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!
3. Команда git restore \<file\> «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.
## Показать изменения файла
1. Команда git diff сравнит последнюю закоммиченную версию файла с той, что находится в состоянии modified. git diff показывает изменения, которые не были добавлены в staged.
Посмотреть изменения с помощью git diff можно, только если они не были проиндексированы или закоммичены.
2. Команда git diff --staged покажет изменения в staged-файлах относительно последних закоммиченных версий
3. git diff a9928ab 11bada1 покажет различия коммитов с хешами a9928ab и 11bada1
## Игнорирование файлов в GIT
1. Список файлов/папок для игнорирования в GIT внести в файл .gitignore и добавить данный файл в commit
2. Синтаксиси файлв .gitignore
- \# - комминт
- filename - игнорировать файл с таким именем в текущей папке и всех подпапках
- \* - соответсвует любой сроке. Например *.log - игнорировать все локи во всех папках проекта
- doc/\*/\*.log - игнорировать все логи во всех подпапках папки doc
- ? - заменяем 1 символ. Пример file?.txt, игнорировать file1.txt, file2.txt, но не игнорировать file12.txt
- [..] - один символ из лиапазона. Например file[1-5].txt - игнорировать file1.txt, но не игнорировать file6.txt. Диапазаоны: [abc], [a-z] и т.д.
- / - указывает на каталог /file.txt -  игнорировать файл в корневом каталоге, без / - игнорировать во всех каталогах, dir/ - игнорировать папку dir/
- \*\* - указывает на любую папку, включая 0 папок. Пример:

	игнорировать файлы "docs/current/tmp", "docs/old/tmp", а также "docs/old/saved/a/b/c/d/tmp"	и даже "docs/tmp", потому что ноль вложенных папок тоже подходит
		docs/\*\*/tmp	
	игнорировать только "docs/current/tmp" и "docs/old/tmp" файл "docs/old/saved/a/b/c/d/tmp" не попадает в правило
		docs/\*/tmp 
- ! - инверсия условия, например:
	
	\*.txt
	!file1.txt
	
	будут игнорироваться все текстовые файлы, кроме file1.txt
	
3. Команда git status не отображает игнорируемые файлы
4. Команда git status --ignored показывает игнорируемые файлы в разделе Ignored files
## Клонирование репозиотрия
1. На стороне GitHub открыть проект, нажать кнопку <>Code и на вкладке SSH скоприровать ссылку для клонирования проекта, например git@github.com:yandex-praktikum/git-clone-practice.git
2. В локальном репозитарии:
	git clone git@github.com:yandex-praktikum/git-clone-practice.git
3. Проект клонируется на локальный диск и локальная копия связывается с удаленным репозиторием
4. Для проверки статуса клонированного проекта перейти в папку с отклонированным проектом и:
	git remote -v
## Fork репозитория
1. «Форк» позволяет получить точную копию GitHub-репозитория в ваш аккаунт.
2. Копия, которая получена с помощью «форка», полностью независима от оригинального проекта — изменения не будут синхронизированы.
3. Чтобы сделать Fork проекта (обычно чужого публичного или приватного, но доступного для Fork), нужно:
- открыть проект в GitHub
- справа вверху найти кнопку Fork и в открывшемся окне нажать снизу кнопку Create Fork
- Проект появится в списке проектов в Вашем аккаунте GitHub
- Далее его можно клонировать в докальный репозиторий в GitHub (кнопка \<\>Code и скопировать путь, затем в локальной консоли в папке .git:

git clone <вставить путь> 

## Ветки проекта Branch

### Общие сведения
1. Ветка — это последовательность независимых изменений.
2. Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.
3. Основная версия проекта хранится в главной ветке main (или master).

### Базовые операции с ветками
1. С помощью команды git branch можно посмотреть, какие в проекте есть ветки и в какой из них вы сейчас находитесь.
2. Создание ветки:

git branch \<название ветки\>


3. Рекомендуемые правила именования веток

feature/\<Описание цепочки фичей, добавляемых по ветке\>
bugfix/\<Описние багов, которые правим по ветке\>

4. Для перехода в ветку:

git checkput \<Название ветки, куда переходим\>

5. Создать ветку и сразу в нее переключиться

git checkout -b \<Название ветки\>

6. Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.

##№ Применение git diff к веткам проекта
1. git diff может сравнивать ветки по их названиям. Например, команда git diff main feature/my-feature выведет разницу между основной веткой и веткой feature/my-feature.
2. Git поддерживает суффикс навигации \~. С его помощью можно сослаться на предыдущие коммиты. Например, если вы находитесь в ветке main и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим, нужно выполнить git diff main\~3 main

##№ Слияние веток проекта
1. Выполнить слияние веток позволяет команда git merge <название_ветки>. В качестве параметра указывают название ветки, которую нужно влить в текущую.
2. Удалять ненужные ветки после слияния — хорошая практика. Так в вашем репозитории всегда будет порядок. За удаление веток отвечает команда git branch -D <название_ветки> и её щадящий вариант с флагом -d
### Конфликты при слиянии
Статья про конфликты и способы их разрешения:
https://git-scm.com/book/ru/v2/Инструменты-Git-Продвинутое-слияние
### Передать ветку в удаленный репозиторий
1. git push -u origin <имя ветки>
2. git checkout feature/new && git push -u origin feature/new - не обязательно переходить в ветку, чтобы ее запушить
### Создать пул-реквест
1. Пул-реквест — это запрос на рассмотрение предлагаемых изменений и часть процесса ревью.
2. Запрос на изменения можно инициировать двумя способами: через ссылку, которую Git выводит после создания ветки, или через интерфейс GitHub.
3. После создания пул-реквеста ваши коллеги сделают ревью — оценят предложенные вами правки и оставят свои комментарии.
4. По результатам ревью ваши правки могут быть приняты в основную ветку проекта или возвращены на доработку.
5. Для создания пул реквеста: открыть проект в GitLab и перейти на вкладку Pull-requests
### Подтянуть изменения из удаленного репозитория
1. Команда git pull - подтягивает в текущу ветку данные из связанной ветки с удаленного репозитория
2. Рекомендуемая последовательность действий перед началом работы при групповой работе в команде:
$ git checkout main # перешли в main


$ git pull # подтянули новые изменения в main
$ git checkout my-branch # вернулись в рабочую ветку my-branch
$ git merge main # влили main в новую ветку my-branch, устранили конфликты с учетом правок, внесенных другими программистами
$ git push -u origin my-branch # отправили ветку my-branch в удалённый репозиторий

# Работв в команде
## Слияние двух веток в режиме Fast Forvard
1. Если истории двух веток не «разошлись» и их коммиты выстраиваются в одну цепочку, эти ветки можно объединить в режиме fast-forward.
2. Режим fast-forward можно отключить с помощью флага --no-ff.
## Слияние двух веток в состянии non-fast forward
1. Если истории двух веток всё же «разошлись», при слиянии веток Git создаст коммит слияния.
2. При объединении веток в состоянии не-fast-forward возможны (но не обязательны) конфликты. Если конфликты всё же возникли, Git попытается разрешить их самостоятельно или попросит вас сделать это вручную.
## Команда Git push и fast-forward
1. Команда git push по сути проводит сличние локальной ветки branch и этой ветки в репозитарии branch@origin
2. Команда git push выполняется успешно, только если branch и branch@origin находятся в состоянии fast-forward.
3. С помощью перебазирования (rebase) ветки возможно добиться состояния fast-forward, даже если раньше было не-fast-forward. Rebase сдвигает коммиты в удвленном репозитарии на дату раньше первого конфликтующего коммита в локальном репозитори. Это может привести к разрушению репозитория.
4. С помощью git push --force происходит передача коммитов локального репозитария в удаленный, при этом конфликтующие коммиты в удаленном репозитории удаляются
## Подходы к управлению ветками при работе в команде
1. Разные компании и команды используют разные модели работы с Git. Эти модели описывают структуру веток в проекте, а также правила создания и слияния коммитов в них.
2. Один из самых простых и популярных подходов — feature branch workflow. Он предполагает, что работа над функциональностью ведётся в отдельной feature-ветке. Когда всё готово, эта ветка вливается в основную.
3. Подход feature branch workflow — лишь шаблон, по которому можно действовать. Многие компании и команды меняют его под свои нужды, но неизменно одно: хочешь сделать новую функциональность или исправить баг — создай новую ветку!
## Review проекта
1. Автор форкает проект (если чужой) или клонирует себе проект (если он участнпик проекта) - через GitHub 
2. В локальной копии проекта создается ветка c именем feature-branch и в ней вносятся нужные изменения (например, правим файл):  
Git add. && git commit -m "Коммент к комиту"
3. Запускаем pull реквест своей ветки и запрашиваем замержить ее с веткой main:  
git push --set-upstream origin HEAD  
или аналогичная команда: git push -u origin feature-branch  
4. Копируем ссылку на Pull-request из результата команды, заходим  на GitHub в наш проект и создаём пул-реквест. Если изменения вносятся в файлы другого пользователя, которые уже есть в ветке main, то потребуется review другого пользователя.
5. Ревьюер просматривает изменения и предлагает правки, если они необходимы.
6. Автор вносит исправления по комментариям ревьюера локально, по правкам создает коммиты и пушит результат на GitHub.  
git push
Пункты 5 и 6 могут повториться!
7. Если ревьюера всё устраивает, он одобряет («апрувит») пул-реквест.
8. Вуаля! Теперь автор или ревьюер могут влить изменения в основную ветку.
## Навыки в программировании и навыки общения
1. *Hard skills*, или хардскилы, — это владение инструментами, причём неважно какими. Умение забивать гвозди молотком, знание команд Git, умение играть на пианино — всё это примеры хардскилов. Именно этому типу навыков мы уделяли больше внимания в нашем курсе.  
2. *Soft skills*, или софтскилы, — это социально-психологические навыки. Например: умение договариваться, умение внятно донести свои мысли или понять идеи собеседника, умение мягко преподнести критику результатов работы.  
3. Все участники проектной команды должны обладать обеими типами навыков.  
*Помните, что ревью — это в первую очередь диалог на тему «сделают ли конкретные изменения этот проект лучше».*
## Разрешение конфликтов если ветка master ушла вперед 
1. Чтобы разрешить конфликт слияния, который возникает, когда главная ветка «уходит» вперёд, можно сделать следующее. Сначала локально получить новые изменения через git pull, а затем выполнить git merge и разрешить конфликт. Далее создать коммит слияния и отправить новые изменения без конфликтов обратно в удалённый репозиторий командой git push.